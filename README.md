# 幂等

幂等，有些地方也称为防重，一般在以下场景中会遇到：
1. 前端重复提交
2. 接口的攻击或测试（和1类似）
3. 接口超时重试
4. 消息队列消息的重复消费

对于不同的场景，实现幂等的方式也可以不同。<br/>
对于像查询这样没有副作用的操作，一般不用进行幂等处理。还有一些操作在业务逻辑上就是幂等的，就也不用进行幂等处理。<br/>
对于页面的重复提交，前端页面可以跳转、按钮置灰的方式在重复发生前阻止重复。<br/>
当然，前端实现的这些功能，一般可以被绕过直接请求接口，所以后端在需要的地方必定要实现幂等。后端实现幂等，按照需求及成本的不同，也有不同的方式。

幂等防重，首先需要定义的是什么是重复，唯一性从何而来。<br/>
为了让我们的唯一性能更通用一些，我们可以：
1. 服务端（生产者）在“事务”开始前，生成token，客户端（消费者）加载时加载token，“事务”请求时带上token，这种情况客户端可以按照自己的逻辑安排什么时候请求token
2. 客户端自行生成id，请求时带上id，这种与1也差不多，只是对于服务端来说，因为客户端有可能是不同类型的，而不同客户端的请求id可能会冲突，因此可以通过consumerId与requestId来唯一标识

在有了唯一性后，接下来的算法也有不同成本和要求：
1. 要求较高，客户端无感，即客户端不需要对服务端的响应做一些处理，这部分实现，可以参考本项目代码<br/>
实现要点：<br/>
1、每一请求的响应，都应落库（同一requestId的只需要落1份），以此来使得对于相同的请求，总是能返回相同的结果；<br/>
2、并发的情况，对于相同请求的两个并发，因事务并发的原因而可能会造成冲突，这时可以直接失败其中一个，并直接丢弃响应；<br/>
或者与客户端约定【处理中】的一种响应，客户端接收到这种响应直接丢弃。<br/>
这里有个小插曲，在实现幂等的时候，因为服务端需要在业务逻辑失败返回客户端前将失败的结果落库，而失败的业务逻辑通常需要rollback，因而本项目代码又有两种不同的事务实现方式。<br/>
使用Propagation.REQUIRES_NEW或Propagation.NESTED。<br/>
使用Propagation.NESTED实现相对简单一些，因为nested的事务与外层事务是同一事务，异常处理起来相对简单。<br/>
而使用Propagation.REQUIRES_NEW的话，因为是两个事务，所以基本上需要当作分布式系统的情况来考虑各种异常。因此单机还是尽量用Propagation.NESTED。
2. 客户端可以对服务端的返回有一定的逻辑处理，如果服务端发现重复以后就返回约定的返回码（响应码）。本人接触到的系统，大多是这种方案，客户端发现重复以后，可以通过另外的接口查询结果或者其它策略，所以看起来更复杂了<br/>
实现细节：
1、并发，对于具体实现如MySQL insert（cusomerId+requestId）来实现的话，可能需要区分键值重复异常和获取锁超时异常/其它异常。<br/>
键值重复异常，返回重复相关返回码，对于其它异常，不管是服务端还是客户端，都对***可能有多个并发的相同请求***的状态未明，对于这种情况，还是要像第1种方式那样直接丢弃或者【处理中】。<br/>
对比第1种方式，少了服务端需要将返回包落库的微小成本，但多了【重复】的返回码，且对客户端的要求高了，耦合了服务端和客户端。因此个人倾向于使用第1中方式。

到了具体实现，按照中间件的可靠性等方面，又可以分为不同的实现：
