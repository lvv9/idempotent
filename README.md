# 可靠幂等

幂等，有些地方也称为防重，一般在以下场景中会遇到：
1. 前端重复提交
2. 接口的攻击或测试（和1类似）
3. 接口超时重试
4. 消息队列消息的重复消费

对于不同的场景，实现幂等的方式也可以不同。<br/>
对于查询这样没有副作用的操作，一般不用进行幂等处理。还有一些操作在业务逻辑上就是幂等的，就也不用进行幂等处理。<br/>
对于页面的重复提交，前端页面可以以跳转、按钮置灰的方式在重复发生前阻止重复。<br/>
当然，前端实现的这些功能，一般可以被绕过直接请求接口，所以后端在需要的地方必定要实现幂等。后端实现幂等，按照各种要求的不同，也有不同的方式。

幂等防重，首先需要定义的是什么是重复，唯一性从何而来。<br/>
为了让我们的唯一性能更通用一些，我们可以：
1. 服务端（生产者）在“事务”开始前，生成token，客户端（消费者）加载时请求token，“事务”请求时带上token，这种情况客户端可以按照自己的逻辑安排什么时候请求token
2. 客户端自行生成id，请求时带上id，这种与1也差不多，只是对于服务端来说，因为客户端有可能是不同类型的，而不同客户端的请求id可能会冲突，因此可以通过consumerId与requestId来唯一标识

在有了唯一性后，接下来对客户端友好程度的不同也有不同的做法：
1. 要求较高，客户端无感，即客户端不需要对服务端的响应做一些处理，这部分实现，可以参考本项目代码<br/>
实现要点：<br/>
1、每一请求的响应，都应落库（同一consumerId+requestId的只需要落1份），以此来使得对于重复的同一请求，总是能返回相同的结果，不管是成功还是失败；<br/>
2、注意并发原子性，对于相同请求的两个并发，因事务并发的原因而可能会造成冲突，这时可以直接失败其中一个，并直接丢弃响应；<br/>
或者与客户端约定【处理中】的一种响应，客户端接收到这种响应重试或直接丢弃。存在冲突或其它未知异常时，在Java注解的声明式事务中应抛出异常，外层可以捕获后返回【处理中】。<br/>
如果是用MySQL实现，需要注意MySQL的隔离级别、并发控制（ [MySQL并发实验](https://liuweiqiang.me/2021/12/03/mysql-concurrent-control-test.html) )。
>这里还有个小插曲，在实现幂等的时候，因为服务端需要在业务逻辑失败返回客户端前将失败的结果落库，而失败的业务逻辑通常需要rollback，因而本项目代码又有两种不同的事务实现方式。<br/>
使用Propagation.REQUIRES_NEW或Propagation.NESTED。<br/>
使用Propagation.NESTED实现相对简单一些，因为nested的事务与外层事务是同一事务，异常处理起来相对简单。<br/>
而使用Propagation.REQUIRES_NEW的话，因为是两个事务，所以基本上需要当作分布式系统的情况来考虑各种异常。因此单机还是尽量用Propagation.NESTED。
2. 客户端可以对服务端的返回有一定的逻辑处理，如果服务端发现重复以后就返回约定的返回码（响应码）。本人接触到的系统，大多是这种方案，客户端发现重复以后，可以通过另外的接口查询结果或者其它策略，对客户端来说更复杂了<br/>
实现细节：<br/>
1、并发，对于具体实现如是用MySQL insert（consumerId+requestId）的话，可能需要区分键值重复异常和获取锁超时异常/其它异常。<br/>
键值重复异常，返回重复相关返回码，对于其它异常，不管是服务端还是客户端，都对请求的状态未明，对于这种情况，服务端返回未明错误，或者还是像第1种方式那样直接丢弃或者返回【处理中】。<br/>
对比第1种方式，少了服务端需要将返回包落库的微小代价，但多了各种异常返回的处理，且无法***一次性***返回除【返回码】以外的信息，对客户端的要求高了，耦合了服务端和客户端。<br/>
对于分布式的系统，通常客户端也作为服务对外暴露API，而较重的客户端处理，容易造成不同客户端的实现缺陷，因此个人倾向于使用第1中方式。

到了具体实现，按照中间件的可靠性等方面，又可以分为不同的实现：
1. 本项目采用的MySQL insert（consumerId+requestId） + 唯一索引约束
2. Redis set相关命令或lua + key唯一约束

由于Redis与MySQL相比可靠性较低，且Redis一般无法与MySQL保持同一事务，在一些不太重要的地方或者失败可接受的情况下可以使用，这里没再深入了。